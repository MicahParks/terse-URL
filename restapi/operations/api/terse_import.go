// Code generated by go-swagger; DO NOT EDIT.

package api

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"context"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	"github.com/MicahParks/terseurl/models"
)

// TerseImportHandlerFunc turns a function with the right signature into a terse import handler
type TerseImportHandlerFunc func(TerseImportParams) middleware.Responder

// Handle executing the request and returning a response
func (fn TerseImportHandlerFunc) Handle(params TerseImportParams) middleware.Responder {
	return fn(params)
}

// TerseImportHandler interface for that can handle valid terse import params
type TerseImportHandler interface {
	Handle(TerseImportParams) middleware.Responder
}

// NewTerseImport creates a new http.Handler for the terse import operation
func NewTerseImport(ctx *middleware.Context, handler TerseImportHandler) *TerseImport {
	return &TerseImport{Context: ctx, Handler: handler}
}

/* TerseImport swagger:route POST /api/import api terseImport

Import existing Terse and Visits data for the given shortened URLs.

Any imported data will overwrite existing data. Unless deletion information is specified. In that case all Terse or Visits data can be deleted before importing the new data.

*/
type TerseImport struct {
	Context *middleware.Context
	Handler TerseImportHandler
}

func (o *TerseImport) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewTerseImportParams()
	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}

// TerseImportBody terse import body
//
// swagger:model TerseImportBody
type TerseImportBody struct {

	// delete
	Delete *models.Delete `json:"delete,omitempty"`

	// import
	Import map[string]models.Export `json:"import,omitempty"`
}

// Validate validates this terse import body
func (o *TerseImportBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDelete(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateImport(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *TerseImportBody) validateDelete(formats strfmt.Registry) error {
	if swag.IsZero(o.Delete) { // not required
		return nil
	}

	if o.Delete != nil {
		if err := o.Delete.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("importDelete" + "." + "delete")
			}
			return err
		}
	}

	return nil
}

func (o *TerseImportBody) validateImport(formats strfmt.Registry) error {
	if swag.IsZero(o.Import) { // not required
		return nil
	}

	for k := range o.Import {

		if err := validate.Required("importDelete"+"."+"import"+"."+k, "body", o.Import[k]); err != nil {
			return err
		}
		if val, ok := o.Import[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this terse import body based on the context it is used
func (o *TerseImportBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDelete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateImport(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *TerseImportBody) contextValidateDelete(ctx context.Context, formats strfmt.Registry) error {

	if o.Delete != nil {
		if err := o.Delete.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("importDelete" + "." + "delete")
			}
			return err
		}
	}

	return nil
}

func (o *TerseImportBody) contextValidateImport(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.Import {

		if val, ok := o.Import[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *TerseImportBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *TerseImportBody) UnmarshalBinary(b []byte) error {
	var res TerseImportBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
